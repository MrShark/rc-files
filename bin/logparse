#!/usr/bin/env python

import ConfigParser
import re
import sys
import time
from cgi import escape
from optparse import OptionParser

def parse_cmdline():
    parser = OptionParser(usage="usage: %prog [options]\n\nReads a stream anoted by loganote and generates a report")
    parser.add_option("-f", "--file", dest="filename", default="buildreport",
                      help="write report to FILE (default %default)", metavar="FILE")
    parser.add_option("-s", "--block-scale", dest="block_scale", default=5, type="int",
                      help="Scaling of the blocks when displayed (default %default)", metavar="SCALE")
    parser.add_option("-c", "--configfile", dest="configfile", default="logparse.cfg",
                      help="read configuration from FILE (default %default)",
                      metavar="FILE")

    return parser.parse_args()

prefilters = None
postfilters = None
classre = None

def read_config(configfile):
    config = ConfigParser.SafeConfigParser()
    config.read(configfile)

    global prefilters
    prefilters = [re.compile(r) for (_, r) in config.items("prefilters", raw=True)]
    global postfilters
    postfilters = [re.compile(r) for (_, r) in config.items("postfilters", raw=True)]

    global classre
    raw_items = config.items("class_strings")
    raw_items.sort()
    classre = [(name, re.compile(pattern)) for (name, pattern) in raw_items]


def prefilter(cmd):
    return any([f.search(cmd) for f in prefilters])

def postfilter(cmd):
    return any([f.search(cmd) for f in postfilters])


def get_class(cmd):
    for (cls, clsre) in classre:
        if clsre.search(cmd):
            return cls
    return ""

def split_line(line):
    try:
        # parsing the time format: 0:00:01.895519 (ie print datetime.timedelta()
        # where days = 0. Crude.
        (t, cmd) = line.split(None,1)
        (hours, minutes, seconds) = t. split(":")
        tid = int(hours)*60*60+int(minutes)*60+float(seconds)
    except (IndexError, ValueError):
        tid = -1
        cmd = line
    return (tid, cmd)

def read_file(fil):
    lines = []

    line = fil.readline()
    last_time = 0
    last_cmd = ""

    while (line):
        (new_time, new_cmd) = split_line(line)
        if new_time > 0:
            lines.append((last_time, new_time, last_cmd))
            last_time = new_time
            last_cmd = new_cmd
        line = fil.readline()
    return lines[1:]




prelude = []
postlude = []
def parse_lines(lines):
    cmds = []
    state = "pre"
    global prelude, postlude
    def output():
        global prelude, postlude
        starttime = command[0]
        if prelude:
            starttime = prelude[0][0]
        endtime = command[1]
        if postlude:
            endtime = postlude[-1][0]

        cmds.append((starttime, endtime, prelude, command, postlude))

        prelude = []
        postlude = []


    for (start_time, end_time, cmd) in lines:
        if prefilter(cmd):
            typ = "pre"
        elif postfilter(cmd):
            typ = "post"
        else:
            typ = "cmd"
        if state == "pre":
            if typ == "pre":
                prelude.append((start_time, end_time, cmd))
            elif typ == "post":
                raise SyntaxError("Illegal statechange")
            elif typ == "cmd":
                command = (start_time, end_time, cmd)
        elif state == "cmd":
            if typ == "pre":
                output()
                prelude.append((start_time, end_time, cmd))
            elif typ == "post":
                postlude.append((start_time, end_time, cmd))
            elif typ == "cmd":
                output()
                command = (start_time, end_time, cmd)
        elif state == "post":
            if typ == "pre":
                output()
                prelude.append((start_time, end_time, cmd))
            elif typ == "post":
                postlude.append((start_time, end_time, cmd))
            elif typ == "cmd":
                output()
                command = (start_time, end_time, cmd)
        state = typ
    output()
    return cmds

def generate_html_lines(cmds, options):
    html = []
    totals = {}
    for (starttime, endtime, prelude, command, postlude) in cmds:
        tot_time = endtime - starttime
        prel_time = command[0] - starttime
        post_time = endtime - command[1]
        style = "width: %spx;" % (tot_time * options.block_scale)
        cls = get_class(command[2])
        line  = "<div style='%s' class='time %s' title='%s'>" % (style, cls, cls)
        line += "<h1>%s</h1>" % cls
        line += "<div class='data'>"
        line += "<dl>"
        line += "<dt>Command Startime</dt><dd>%s</dd>"
        line += "<dt>Total running time</dt><dd>%s</dd>" % tot_time
        line += "<dt>Prelude running time</dt><dd>%s</dd>" % prel_time
        line += "<dt>Postlude running time</dt><dd>%s</dd>" % post_time
        line += "</dl>"
        line += "<h2>Prelude</h2>"
        line += "<pre>%s</pre>" % escape(" ".join([c[2] for c in prelude]))
        line += "<h2>Command</h2>"
        line += "<pre>%s</pre>" % escape(command[2])
        line += "<h2>Postlude</h2>"
        line += "<pre>%s</pre>" % escape(" ".join([c[2] for c in postlude]))
        line += "</div>"
        line += "</div>"
        html.append(line)
        totals[cls] = totals.get(cls,0) + tot_time
    return (html, totals)



def output_html(output, html_lines, totals):
    output.write("""<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN">
    <html>
    <head>
    <title>Build report</title>
    <script type="text/javascript" src="http://ajax.googleapis.com/ajax/libs/jquery/1.4.1/jquery.min.js"></script>


    <style type="text/css">
      body {font-size:10px;}
      .time {overflow:hidden; xborder:1px solid black; margin:20px 0; height: 100px; float:left;}
      .time.selected {margin:10px 0; height: 120px;}
      .time>h1 {font-size:20px; -moz-transform-origin: left top; -moz-transform: rotate(90deg) translate(-.4em, -1.1em);}
      .time>.data {display:none}
      .displaybox {width: auto; border 1px solid red;clear:both;font-size:15px}
      .displaybox>h1 {display:none}
      table {clear:both; font-size:20px}
    """)

    colors = [
        ('#fce94f', '#000'), # Butter 1
        ('#729fcf', '#000'), # Sky Blue 1
        ('#fcaf3e', '#000'), # Orange 1
        ('#73d216', '#000'), # Chameleon 2
        ('#e9b96e', '#000'), # Chocolate 1
        ('#edd400', '#000'), # Butter 2
        ('#8ae234', '#000'), # Chameleon 1
        ('#ce5c00', '#fff'), # Orange 3
        ('#cc0000', '#fff'), # Scarlet Red 2
        ('#c4a000', '#fff'), # Butter 3
        ('#c17d11', '#fff'), # Chocolate 2
        ('#ad7fa8', '#fff'), # Plum 1
        ('#a40000', '#fff'), # Scarlet Red 3
        ('#8f5902', '#fff'), # Chocolate 3
        ('#75507b', '#fff'), # Plum 2
        ('#f57900', '#fff'), # Orange 2
        ('#ef2929', '#fff'), # Scarlet Red 1
        ('#5c3566', '#fff'), # Plum 3
        ('#4e9a06', '#fff'), # Chameleon 3
        ('#3465a4', '#fff'), # Sky Blue 2
        ('#204a87', '#fff'), # Sky Blue 3
    ]
    for (cls, col) in zip(classre, colors):
        output.write("  .%s {background: %s; color: %s}\n" % (cls[0], col[0], col[1]))
    output.write("""
    </style>
    </head>
    <body>
    """)
    for line in html_lines:
        output.write(line+"\n")

    tot_time = 0
    for cls in totals:
        tot_time += totals[cls]

    indexes = totals.keys()
    indexes.sort(key = lambda x:totals[x])
    urllegends = []
    urllabels = []
    urlvalues = []

    output.write("<table>")
    output.write("<tr><th>What</th><th>Running time</th><th>Percentual time</th></tr>\n")
    for cls in indexes:
        if cls != "":
            output.write("<tr><td class='%s'>%s</td><td>%.3f s</td><td>%.1f%%</td></tr>\n" % (cls, cls, totals[cls], 100*totals[cls]/tot_time))
            urllegends.append(cls)
            urllabels.append("%.1f%%25" % (100*totals[cls]/tot_time))
            urlvalues.append("%f" % totals[cls])
    output.write("<tr><td>Rest</td><td>%.3f s</td><td>%.1f%%</td></tr>\n" % (totals.get("",0), 100*totals.get("",0)/tot_time))
    output.write("<tr><td>Total</td><td>%.3f s</td><td>100.0%%</td></tr>\n" % (tot_time))
    output.write("</table>\n")

    urllegends.append("Rest")
    urllabels.append("%.1f25%%" % (100*totals.get("",0)/tot_time))
    urlvalues.append("%f" % totals.get("",0))
    output.write('<img src="http://chart.apis.google.com/chart?chs=300x225&cht=p3&chd=t:%s&chdl=%s&chl=%s&chtt=Build+time+distribution" width="300" height="225" alt="Build time distribution" />' %
            (",".join(urlvalues), "|".join(urllegends), "|".join(urllabels),)
            )

    output.write("""
    <div class='displaybox'><div></div></div>
    <script>
    $(".time").click(
      function () {
        $(this).clone().removeClass("time").removeAttr("style").replaceAll(".displaybox>div");
        $(".selected").removeClass("selected");
        $(this).addClass("selected");
      }
    );

    </script>

    </body>
    </html>
    """)


if __name__ == "__main__":
    (options, args) = parse_cmdline()
    read_config(options.configfile)
    output = open(options.filename, "w")
    lines = read_file(sys.stdin)
    cmds = parse_lines(lines)
    (html_lines, totals) = generate_html_lines(cmds, options)
    output_html(output, html_lines, totals)
